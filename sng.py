# Copyright 2013 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

"""A ninja generator for simple projects. No configuration files, replaced by
ridiculously regimented project structure that you probably won't like.
"""

import ConfigParser
import glob
import optparse
import os
import subprocess
import sys


def Run(args, cwd=None):
  assert isinstance(args, list)
  subprocess.check_call(args, shell=True, cwd=cwd)


def GitPullOrClone(remote):
  base = os.path.splitext(os.path.basename(remote))[0]
  if not os.path.exists('third_party/%s/.git' % base):
    Run(['git', 'clone', remote], cwd='third_party')
  else:
    Run(['git', 'pull'], cwd='third_party/%s' % base)


def DEP_ninja(action):
  if action == 'sync':
    GitPullOrClone('https://github.com/martine/ninja.git')
    if os.path.exists('third_party/ninja/ninja.bootstrap.exe'):
      Run(['ninja.bootstrap.exe'], cwd='third_party/ninja')
    elif os.path.exists('third_party/ninja/ninja.exe'):
      Run(['ninja.exe'], cwd='third_party/ninja')
    elif os.path.exists('third_party/ninja/ninja'):
      Run(['ninja'], cwd='third_party/ninja')
    else:
      Run([sys.executable, 'bootstrap.py'], cwd='third_party/ninja')


def DEP_googletest(action):
  if action == 'sync':
    if not os.path.exists('third_party/googletest/.svn'):
      Run(['svn', 'checkout',
           'http://googletest.googlecode.com/svn/trunk/@HEAD', 'googletest'],
          cwd='third_party')
    else:
      Run(['svn', 'up'], cwd='third_party/googletest')


CFLAGS = [
    '/Zi', '/W4', '/WX', '/GR-',
    '/wd4530',
    '/D_WIN32_WINNT=0x0501',
    '/D_CRT_SECURE_NO_WARNINGS',
    '/DNOMINMAX',
    '/Isrc',
  ]
CFLAGS_DEBUG = [
    '/D_DEBUG',
  ]
CFLAGS_RELEASE = [
    '/Ox',
    '/GL',
    '/DNDEBUG',
  ]
LDFLAGS = [
    '/DLL',
  ]
LDFLAGS_DEBUG = [
  ]
LDFLAGS_RELEASE = [
    '/LTCG',
  ]


for helper in glob.glob('sng_*.py'):
  execfile(helper, globals())


def UpdateDeps():
  for name, func in globals().iteritems():
    if name.startswith('DEP_'):
      func('sync')


def GetFromDeps(into, action):
  for name, func in globals().iteritems():
    if name.startswith('DEP_'):
      result = func(action)
      if result:
        into.extend(result)


def ForwardSlash(path):
  return os.path.normpath(path).replace('\\', '/')


def Compile(n, target, libtags):
  objs = []
  libs = set()
  for topdir, dirnames, filenames in os.walk(os.path.join('src', target)):
    print topdir, dirnames, filenames
    for filename in filenames:
      ext = os.path.splitext(filename)[1]
      if ext in ('.cc', '.cpp', '.cxx'):
        src_path = ForwardSlash(os.path.join(topdir, filename))
        with open(src_path, 'r') as f:
          contents = f.read()
          for libtag, libname in libtags:
            if libtag in contents:
              libs.add(libname)
        assert src_path.startswith('src')
        obj_path = '$builddir/' + ForwardSlash(
            src_path[4:] + '.obj').replace('/', '.')
        variables = None
        if '_test' in filename:
          variables = (('cflags', '$cflags_test'),)
        n.build(obj_path, 'cxx', src_path, variables=variables)
        objs.append(obj_path)
  return objs, list(libs)


def BinaryAndRuleForTarget(target):
  if target.endswith('_dll'):
    return '$builddir/' + target[:-4] + '.dll', 'linkdll'
  elif target.endswith('_exe'):
    return '$builddir/' + target[:-4] + '.exe', 'link'
  else:
    return '$builddir/' + target + '.lib', 'lib'


def BuildLibTags(target, targets):
  libtags = []
  for t in targets:
    if target == t:
      continue
    if not t.endswith('_dll') and not t.endswith('_exe'):
      libtags.append(('#include "%s/' % t, '$builddir/%s.lib' % t))
  return libtags
  

def Generate(is_debug):
  if not os.path.exists('out'):
    os.makedirs('out')
  sys.path.append('third_party/ninja/misc')
  import ninja_syntax
  with open('build.ninja', 'w') as output_file:
    n = ninja_syntax.Writer(output_file)
    n.comment('Generated by sn.py')
    n.newline()

    n.variable('ninja_required_version', '1.3')
    n.newline()

    assert sys.platform == 'win32'
    n.variable('builddir', 'out')

    cflags = CFLAGS[:]
    have_common = os.path.exists('src/common')
    GetFromDeps(cflags, 'cflags')
    if is_debug:
      GetFromDeps(cflags, 'cflags_debug')
    else:
      GetFromDeps(cflags, 'cflags_release')
    n.variable('cflags', cflags)

    cflags_test = cflags[:]
    cflags_test += [
        '/Ithird_party/googletest/include',
        '/D_VARIADIC_MAX=10',
      ]
    GetFromDeps(cflags_test, 'cflags_test')
    n.variable('cflags_test', cflags_test)
    n.newline()

    n.rule('cxx',
           command='cl /nologo /showIncludes $cflags -c $in /Fo$out',
           description='CXX $out',
           deps='msvc')
    n.rule('lib',
           command='lib /nologo $arflags /out:$out $in',
           description='LIB $out')
    n.rule('link',
           command='cl /nologo $in $libs /link $ldflags /out:$out',
           description='LINK $out')
    n.rule('linkdll',
           command='cl /nologo $in $libs /link $ldflags /DLL /out:$out',
           description='LINK DLL $out')
    n.newline()

    targets = [os.path.basename(x) for x in glob.glob('src/*')]
    all_binaries = []
    for target in targets:
      objs, libs = Compile(n, target, BuildLibTags(target, targets))
      name, rule = BinaryAndRuleForTarget(target)
      n.build(name, rule, objs, variables=(('libs', libs),))
      all_binaries.append(name)
    n.newline()

    n.comment('Regenerate build file if build script changes.')
    n.rule('configure', command=sys.executable + ' sng.py', generator=1)
    n.build('build.ninja', 'configure',
            implicit=['sng.py', 'third_party/ninja/misc/ninja_syntax.py'])
    n.newline()

    n.build('all', 'phony', all_binaries)


def main():
  parser = optparse.OptionParser()
  parser.add_option("-d", "--debug",
                    action="store_true", dest="debug", default=False,
                    help="build Debug build (default Release)")
  parser.add_option("-u", "--update-deps",
                    action="store_true", dest="update_deps", default=False,
                    help="Pull or update third party dependencies")

  (options, args) = parser.parse_args()
  if len(args) != 0:
    parser.error('unexpected args')

  if options.update_deps:
    UpdateDeps()
  Generate(options.debug)
  return 0


if __name__ == '__main__':
  sys.exit(main())
